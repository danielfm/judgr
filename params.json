{"body":"# Judgr\r\n\r\n[![Build Status](https://secure.travis-ci.org/danielfm/judgr.png)](http://travis-ci.org/danielfm/judgr)\r\n\r\nJudgr (pronounced as judger) is a\r\n[naïve Bayes classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\r\nlibrary written in Clojure which features multivariate classification,\r\nsupport for cross validation, and more.\r\n\r\n## Features\r\n\r\n* Multivariate classification\r\n* Biased and unbiased class probabability\r\n* Configurable [Laplace Smoothing](http://en.wikipedia.org/wiki/Additive_smoothing)\r\n* Configurable threshold validation\r\n* K-fold cross-validation\r\n  * Precision, Recall, Specificity, Accuracy, and F1 score\r\n\r\n## Getting Started\r\n\r\nAdd the following dependency to your _project.clj_ file:\r\n\r\n````clojure\r\n\r\n[judgr \"0.2.0\"]\r\n````\r\n\r\n### Training The Classifier\r\n\r\nThe first step is to instantiate the classifier given the current settings:\r\n\r\n````clojure\r\n\r\nuser=> (use '[judgr.core]\r\n            '[judgr.settings])\r\nnil\r\nuser=> (def classifier (classifier-from settings))\r\n#'user/classifier\r\n````\r\n\r\nNow you can start training the classifier with `(.train! classifier item :class)`:\r\n\r\n````clojure\r\n(.train! classifier \"How are you?\" :positive)\r\n(.train! classifier \"Burn in hell!\" :negative)\r\n(.train! classifier ...)\r\n````\r\n\r\nIf you want to train all examples of a given class at once, there's\r\nalso `(.train-all! classifier items :class)`:\r\n\r\n````clojure\r\n(def positive-items [\"How are you?\" ...])\r\n(def negative-items [\"Burn in hell!\" ...])\r\n\r\n(.train-all! classifier positive-items :positive)\r\n(.train-all! classifier negative-items :negative)\r\n````\r\n\r\nThe default classifier saves data to memory and are capable of\r\nextracting words from the given text using a porter stemmer. Also,\r\nitems can be classified as either `:positive` or `:negative`. If your\r\nproblem requires different settings, please take a look at the\r\n_Extending The Classifier_ section below.\r\n\r\n### Classifying Items\r\n\r\nAfter some training you should be able to use the classifier to guess\r\non which class that item falls into:\r\n\r\n````clojure\r\n\r\nuser=> (.classify classifier \"Long time, no see.\")\r\n:positive\r\nuser=> (.classify classifier \"Go to hell.\")\r\n:negative\r\n````\r\n\r\nIt's also possible to get the probabilities for all classes:\r\n\r\n````clojure\r\n\r\nuser=> (.probabilities \"Long time, no see.\")\r\n{:negative 0.38461539149284363, :positive 0.6153846383094788}\r\n````\r\n\r\n### Evaluating The Classifier\r\n\r\nIt's not that trivial to measure how well the classifier is\r\ngeneralizing to examples it doesn't know about. Fortunately, there's a\r\ncommon technique to evaluate an algorithm's performance that is known\r\nas [Cross-validation](http://en.wikipedia.org/wiki/Cross-validation).\r\n\r\nThe output of a _K_-Fold Cross-validation process is a\r\n[Confusion Matrix](http://en.wikipedia.org/wiki/Confusion_matrix).\r\n\r\n````clojure\r\n\r\nuser=> (use 'judgr.cross-validation)\r\nnil\r\nuser=> (def conf-matrix (k-fold-crossval 2 classifier))\r\n#'user/conf-matrix\r\nuser=> conf-matrix\r\n{:positive {:positive 102\r\n            :negative 3}\r\n :negative {:positive 7\r\n            :negative 186}}\r\n````\r\n\r\nThis Confusion Matrix will tell, for each known class, how many items\r\nit predicted correctly, and how many items it predicted as being in\r\nanother class. For example, for all items known as `:positive`, 102 items\r\nwere flagged correctly and 3 were flagged incorrectly as `:negative`.\r\n\r\nAlthough this helps, it would be nice to have ways to calculate a\r\nsingle number score.\r\n\r\n#### Accuracy\r\n\r\nThe Accuracy is the percentage of predictions that the classifier got\r\ncorrect:\r\n\r\n````clojure\r\n\r\nuser=> (accuracy conf-matrix)\r\n144/149\r\n````\r\n\r\nIn case of low accuracy, there are other calculations that might help\r\nyou identify what's wrong.\r\n\r\n#### Precision\r\n\r\n_Precision_ is a measure of the accuracy provided that a specific\r\nclass has been predicted:\r\n\r\n````clojure\r\n\r\nuser=> (precision :positive conf-matrix)\r\n102/109\r\nuser=> (precision :negative conf-matrix)\r\n62/63\r\n````\r\n\r\n#### Recall\r\n\r\n_Recall_ is a measure of the ability of a model to select instances of\r\na certain class from a data set. It is commonly also called\r\n_Sensitivity_, and corresponds to the true positive rate:\r\n\r\n````clojure\r\n\r\nuser=> (recall :positive conf-matrix)\r\n34/35\r\nuser=> (recall :negative conf-matrix)\r\n186/193\r\nuser=> (sensitivity :negative conf-matrix)\r\n186/193\r\n````\r\n\r\n#### F1 Score\r\n\r\nF1 Score is a weighted average of the precision and recall of a given\r\nclass:\r\n\r\n````clojure\r\n\r\nuser=> (f1-score :positive conf-matrix)\r\n102/107\r\nuser=> (f1-score :negative conf-matrix)\r\n186/191\r\n````\r\n\r\n#### References\r\n\r\n1. [Accurary and precision](http://en.wikipedia.org/wiki/Accuracy_and_precision)\r\n2. [Precision and recall](http://en.wikipedia.org/wiki/Precision_and_recall)\r\n\r\n## Extending The Classifier\r\n\r\nThere are several ways to change the way the classifier works.\r\n\r\n### Supported Classes\r\n\r\nChange the `[:classes]` setting to the classes you want to use. For\r\nexample, if you are building a spam classifier:\r\n\r\n````clojure\r\n\r\n(use 'judgr.settings)\r\n\r\n(def my-settings\r\n  (update-settings settings\r\n                   [:classes] [:ham :spam]\r\n                   [:classifier :default :thresholds] {:ham 1.2\r\n                                                       :spam 2.5}))\r\n````\r\n\r\nNote that we also specified thresholds for the new classes.\r\n\r\n### Feature Extraction\r\n\r\n#### English And Brazilian Portuguese\r\n\r\nWe provide simple implementations for English (default) and Brazilian\r\nPortuguese, based on the work done in\r\n[Apache Lucene](http://lucene.apache.org/core/).\r\n\r\n#### Providing Your Own Feature Extractor\r\n\r\nThe first thing you have to do is create a type that extends the\r\n`FeatureExtractor` protocol:\r\n\r\n````clojure\r\n\r\n(ns your-ns\r\n  (:use [judgr.extractor.base]))\r\n\r\n(deftype CustomExtractor [settings]\r\n  FeatureExtractor\r\n\r\n  (extract-features [fe item]\r\n    ;; Feature extraction logic here\r\n    ))\r\n````\r\n\r\nFinally, define a new method for `extractor-from` multimethod that\r\nknows how to create a new instance of `CustomExtractor`:\r\n\r\n````clojure\r\n\r\n(ns your-ns\r\n  (:use [judgr.core]))\r\n\r\n(defmethod extractor-from :custom [settings]\r\n  (CustomExtractor. settings))\r\n````\r\n\r\nTo use the new extractor, just create a new settings map with\r\n`[:extractor :type]` setting configured to `:custom`, the same key\r\nused in `defmethod`:\r\n\r\n````clojure\r\n\r\nuser=> (use 'judgr.settings)\r\nnil\r\nuser=> (def my-settings\r\n         (update-settings settings\r\n                          [:extractor :type] :custom))\r\n#'user/my-settings\r\nuser=> (extractor-from my-settings)\r\n#<CustomExtractor ...>\r\n````\r\n\r\n### Database Integration\r\n\r\n#### Memory\r\n\r\nIn-memory integration is enabled by default.\r\n\r\n#### Third-Party Database Support\r\n\r\nThere are ready-to-use integration packages for other databases:\r\n\r\n* [MongoDB](https://github.com/danielfm/judgr-mongodb)\r\n* [Redis](https://github.com/danielfm/judgr-redis)\r\n\r\n#### Providing Your Own Database Layer\r\n\r\nThe procedure is similar to what was shown in _Providing Your Own\r\nFeature Extractor_ section.\r\n\r\nFirst, create a new type that extends the `FeatureDB` protocol:\r\n\r\n````clojure\r\n\r\n(ns your-ns\r\n  (:use [judgr.db.base]))\r\n\r\n(deftype CustomDB [settings]\r\n  FeatureDB\r\n\r\n  (add-item! [db item class]\r\n    ;; ...\r\n    )\r\n\r\n  ;; Implement the other methods\r\n)\r\n````\r\n\r\nThen, define a new method for `db-from` multimethod that knows how to\r\ncreate a new instance of `CustomDB`:\r\n\r\n````clojure\r\n\r\n(ns your-ns\r\n  (:use [judgr.core]))\r\n\r\n(defmethod db-from :custom [settings]\r\n  (CustomDB. settings))\r\n````\r\n\r\nTo use the new database layer, just create a new settings map with\r\n`[:database :type]` setting configured to `:custom`, the same key used\r\nin `defmethod`:\r\n\r\n````clojure\r\n\r\nuser=> (use 'judgr.settings)\r\nnil\r\nuser=> (def my-settings\r\n         (update-settings settings\r\n                          [:database :type] :custom))\r\n#'user/settings\r\nuser=> (db-from my-settings)\r\n#<CustomDB ...>\r\n````\r\n\r\n### Classifier Implementation\r\n\r\n#### Default Classifier\r\n\r\nThere's a default classifier implementation that should be enough for\r\nmost cases since it is already fairly configurable.\r\n\r\n##### Threshold Validation\r\n\r\nIf threshold validation is enabled,\r\ni.e. `[:classifier :default :threshold?]` setting is `true`, an item\r\nwill only be flagged as a class if its probability is at least _X_\r\ntimes greater than the second highest probability. The threshold for\r\neach class can be configured in `[:classifier :default :thresholds]`\r\nsetting:\r\n\r\n````clojure\r\n\r\n(use 'judgr.settings)\r\n\r\n(def my-settings\r\n  (update-settings settings\r\n                   [:classifier :default :threshold?] true\r\n                   [:classifier :default :thresholds] {:positive 1 :negative 2}))\r\n````\r\n\r\nIf the probabilities for an item are `{:positive 0.45 :negative 0.55}`, and\r\ntheir thesholds are 1 and 2, respectively, the item will be flagged\r\nwith the value defined in `[:classifier :default :unknown-class]`\r\nsetting, which is `:unknown` by default.\r\n\r\n##### Smoothing\r\n\r\nSmoothing is enabled by default, and it's useful to deal with unknown\r\nfeatures by not returning a flat zero probability.\r\n\r\nYou can change the `[:classifier :default :smoothing-factor]` setting\r\nto change the smoothing intensity, although the default value is\r\nusually good enough:\r\n\r\n````clojure\r\n\r\n(use 'judgr.settings)\r\n\r\n(def my-settings\r\n  (update-settings settings\r\n                   [:classifier :default :smoothing-factor] 0.7))\r\n````\r\n\r\nAlthough it's not recommended, you can turn smoothing off by changing\r\nthe `[:classifier :default :smoothing-factor]` setting to zero.\r\n\r\n##### Using Unbiased Class Probabilities\r\n\r\nBy default, class probabilities are calculated in a _biased_ fashion,\r\nthat is, considering the number of items flagged in each class. For\r\nexample, considering smoothing is disabled, if there's no item flagged\r\nas `:negative`, the probability _P(negative) = 0_. Similarly, if\r\nthere's 3 negative items out of 10, then _P(negative) = 3/10_.\r\n\r\nIf the `[:classifier :default :unbiased?]` setting is configured to\r\n`true`, the probability _P(any_class) = 1/(number_of_classes)_:\r\n\r\n````clojure\r\n\r\n(use 'judgr.settings)\r\n\r\n(def my-settings\r\n  (update-settings settings\r\n                   [:classifier :default :unbiased?] true))\r\n```\r\n\r\n### Providing Your Own Classifier\r\n\r\nFirst, create a new type that extends the `Classifier` protocol:\r\n\r\n````clojure\r\n\r\n(ns your-ns\r\n  (:use [judgr.classifier.base]))\r\n\r\n(deftype CustomClassifier [settings db extractor]\r\n  Classifier\r\n\r\n  (train! [c item class]\r\n    ;; ...\r\n    )\r\n\r\n  ;; Implement the other methods\r\n)\r\n````\r\n\r\nThen, define a new method for `classifier-from` multimethod that knows\r\nhow to create a new instance of `CustomClassifier`:\r\n\r\n````clojure\r\n\r\n(ns your-ns\r\n  (:use [judgr.core]))\r\n\r\n(defmethod classifier-from :custom [settings]\r\n  (let [db (db-from settings)\r\n        extractor (extractor-from settings)]\r\n    (CustomClassifier. settings db extractor)))\r\n````\r\n\r\nTo use the new classifier, just create a new settings map with\r\n`[:classifier :type]` setting configured to `:custom`, the same key\r\nused in `defmethod`:\r\n\r\n````clojure\r\n\r\nuser=> (use 'judgr.settings)\r\nnil\r\nuser=> (def my-settings\r\n         (update-settings settings\r\n                          [:classifier :type] :custom))\r\n#'user/settings\r\nuser=> (classifier-from my-settings)\r\n#<CustomClassifier ...>\r\n````\r\n\r\n## License\r\n\r\nCopyright (C) Daniel Fernandes Martins\r\n\r\nDistributed under the New BSD License. See COPYING for further details.\r\n","tagline":"Multi-class Naïve Bayes Classifier library written in Clojure.","google":"UA-761701-12","name":"Judgr","note":"Don't delete this file! It's used internally to help with page regeneration."}